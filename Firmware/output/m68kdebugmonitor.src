       section   code
; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space

;StackPointerVal     equ $08040000      when using sram
StackPointerVal     equ $0C000000      when using dram

; define RamVectorTable as $0803000 if your system uses SRAM for main memory
; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)

;RamVectorTable      equ $08030000      when using sram
RamVectorTable      equ $0B000000      when using dram



; CSTART.ASM  -  C startup-code for Debug Monitor
                align

                org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0

InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
InitialPC       dc.l start             ;address of 1st instruction of program after a reset
BusError        dc.l E_BErro           ;bus error - stop program
AddressError    dc.l E_AErro           ;address error - stop program
IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
Check           dc.l E_Check           ;Check instruction - stop program
TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
Privilege       dc.l E_Priv            ;privilige violation - stop program
Trace           dc.l E_Trace           ;stop on trace
Line1010emul    dc.l E_1010            ;1010 instructions stop
Line1111emul    dc.l E_1111            ;1111 instructions stop
Unassigned1     dc.l E_Unnas1           ;unassigned vector
Unassigned2     dc.l E_Unnas2           ;unassigned vector
Unassigned3     dc.l E_Unnas3           ;unassigned vector
Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
Unassigned4     dc.l E_Unnas4           ;unassigned vector
Unassigned5     dc.l E_Unnas5           ;unassigned vector
Unassigned6     dc.l E_Unnas6           ;unassigned vector
Unassigned7     dc.l E_Unnas7           ;unassigned vector
Unassigned8     dc.l E_Unnas8           ;unassigned vector
Unassigned9     dc.l E_Unnas9           ;unassigned vector
Unassigned10    dc.l E_Unnas10           ;unassigned vector
Unassigned11    dc.l E_Unnas11           ;unassigned vector
SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
*
*
Level1IRQ       dc.l Level1RamISR
Level2IRQ       dc.l Level2RamISR
Level3IRQ       dc.l Level3RamISR
Level4IRQ       dc.l Level4RamISR
Level5IRQ       dc.l Level5RamISR
Level6IRQ       dc.l Level6RamISR
Level7IRQ       dc.l Level7RamISR
*
*
Trap0           dc.l Trap0RamISR        ; User installed trap handler
Trap1           dc.l Trap1RamISR        ; User installed trap handler
Trap2           dc.l Trap2RamISR        ; User installed trap handler
Trap3           dc.l Trap3RamISR        ; User installed trap handler
Trap4           dc.l Trap4RamISR        ; User installed trap handler
Trap5           dc.l Trap5RamISR        ; User installed trap handler
Trap6           dc.l Trap6RamISR        ; User installed trap handler
Trap7           dc.l Trap7RamISR        ; User installed trap handler
Trap8           dc.l Trap8RamISR        ; User installed trap handler
Trap9           dc.l Trap9RamISR        ; User installed trap handler
Trap10          dc.l Trap10RamISR       ; User installed trap handler
Trap11          dc.l Trap11RamISR       ; User installed trap handler
Trap12          dc.l Trap12RamISR       ; User installed trap handler
Trap13          dc.l Trap13RamISR       ; User installed trap handler
Trap14          dc.l Trap14RamISR       ; User installed trap handler
Trap15          dc.l Trap15RamISR       ; User installed trap handler

*
* Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
*

                org       $00000400

start:          move.w     #$2700,SR             set interrupts to disable until later

*************************************************************************************
** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
** important, it just creates read and write bus cycles to specific addresses which
** help with debugging hardware in Quartus simulations
**************************************************************************************

                ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation

                move.l     #$11223344,$08060000 write 32 bits, to memory
                move.l     $08060000,d0         read 32 bits back
                move.b     #$00,$00400000         write to the output ports
                move.b     #$00,$00400002         write to the output ports
                move.b     #$00,$00400004         write to the output ports
                move.b     #$00,$00400006         write to the output ports
                move.b     #$00,$00400008         write to the output ports
                move.b     #$00,$00400010         write to the hex display ports
                move.b     #$00,$00400012         write to the hex display ports
                move.b     #$00,$00400014         write to the hex display ports
                move.b     #0,$00400020         write to the LCD
                move.b     #0,$00400022         write to the LCD
                move.b     #0,$00400030         write to the Timer1 Data
                move.b     #0,$00400032         write to the Timer1 Control

                ; some important initialisation do not modify
                move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
                move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
                move.l    #heap,__heap    ; pointer to free memory


mainloop        jsr       _main
                bra       mainloop

*********************************************************************************************************
* Code to call Ram Based Interrupt handler and other exeception handler code
*********************************************************************************************************
Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL1IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL2IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL3IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL4IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

* Trace trap Handler

Level5RamISR
*
**         Copy 68000 registers from debug monitor Variables,
*
*
                move.l    #1,_Trace              switch on Trace Mode
                move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
                move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
                move.l    (sp)+,_PC              get at the users program counter and copy
*
                move.l    SP,_SSP                copy system stack pointer to debug monitor variable
                move.l    d0,_d0
                move.l    d1,_d1
                move.l    d2,_d2
                move.l    d3,_d3
                move.l    d4,_d4
                move.l    d5,_d5
                move.l    d6,_d6
                move.l    d7,_d7
*
                move.l    a0,_a0
                move.l    a1,_a1
                move.l    a2,_a2
                move.l    a3,_a3
                move.l    a4,_a4
                move.l    a5,_a5
                move.l    a6,_a6
                move.l    usp,a0
                move.l    a0,_USP
*
                move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
                jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address

** After trace, reload 68000 registers with new values before continuing

                move.l   _d0,d0
                move.l   _d1,d1
                move.l   _d2,d2
                move.l   _d3,d3
                move.l   _d4,d4
                move.l   _d5,d5
                move.l   _d6,d6
                move.l   _d7,d7

                move.l   _USP,a0
                move.l   a0,USP                     load user stack pointer
                move.l   _a0,a0
                move.l   _a1,a1
                move.l   _a2,a2
                move.l   _a3,a3
                move.l   _a4,a4
                move.l   _a5,a5
                move.l   _a6,a6

                move.l   _SSP,sp
                move.l   _PC,-(sp)
                move.w   _SR,-(sp)
                move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
                rte

* address trap handler

Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL6IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VL7IRQ,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte


********************************************************************************************************
* Ram based Trap handler and other exeception handler code
*********************************************************************************************************

Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap0,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap1,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap2,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap3,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap4,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap5,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap6,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap7,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap8,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap9,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap10,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap11,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap12,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrap13,a0                get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte

Trap14RamISR    ;Break Point Handler
*
**         Copy 68000 registers from debug monitor Variables
*
                move.l    #1,_Trace      switch on Trace Mode
                move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
                move.l    (sp)+,_PC      get at the users program counter and copy
*
                move.l    d0,_d0
                move.l    d1,_d1
                move.l    d2,_d2
                move.l    d3,_d3
                move.l    d4,_d4
                move.l    d5,_d5
                move.l    d6,_d6
                move.l    d7,_d7
*
                move.l    a0,_a0
                move.l    a1,_a1
                move.l    a2,_a2
                move.l    a3,_a3
                move.l    a4,_a4
                move.l    a5,_a5
                move.l    a6,_a6
                move.l    USP,a0
                move.l    a0,_USP
*
                move.l    VTrap14,a0             get ram based address into a0
                jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address

** After breakpoint reload 68000 registers with new values before continuing

*                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
                move.l   _d0,d0
                move.l   _d1,d1
                move.l   _d2,d2
                move.l   _d3,d3
                move.l   _d4,d4
                move.l   _d5,d5
                move.l   _d6,d6
                move.l   _d7,d7

                move.l   _USP,a0
                move.l   a0,USP        load user stack pointer A7
                move.l   _a0,a0
                move.l   _a1,a1
                move.l   _a2,a2
                move.l   _a3,a3
                move.l   _a4,a4
                move.l   _a5,a5
                move.l   _a6,a6

                move.l   _PC,-(sp)
                move.w   _SR,-(sp)
                rte

Trap15RamISR    jmp     _CallDebugMonitor
*                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
*                move.l    VTrap15,a0                get ram based address into a0
*                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
*                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
*                rte

*********************************************************************************************************
*Default exception handler for everything without a specific handler
*********************************************************************************************************

*
**              Jump here for each unhandled exception
**              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
*

E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VBusError,a0            get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VAddressError,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VIllegalInstr,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VDividebyZero,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VCheck,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrapV,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VPrivilege,a0           get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VTrace,a0               get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VLine1010emul,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                move.l    VLine1111emul,a0        get ram based address into a0
                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                rte
E_Unnas1
E_Unnas2
E_Unnas3
E_UnitI
E_Unnas4
E_Unnas5
E_Unnas6
E_Unnas7
E_Unnas8
E_Unnas9
E_Unnas10
E_Unnas11
E_Spuri
_stop            bra _stop                         stop
***************************************************************************************************
* Go() function in debug monitor
***************************************************************************************************
_go
                move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
                move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
                move.w   _SR,-(sp)      copy debug monitor status reg to the stack

                move.b   $00000078,d0  remove any spurious address exception arising after power on
                move.l   _d0,d0
                move.l   _d1,d1
                move.l   _d2,d2
                move.l   _d3,d3
                move.l   _d4,d4
                move.l   _d5,d5
                move.l   _d6,d6
                move.l   _d7,d7

                move.l   _USP,a0
                move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
                move.l   _a0,a0
                move.l   _a1,a1
                move.l   _a2,a2
                move.l   _a3,a3
                move.l   _a4,a4
                move.l   _a5,a5
                move.l   _a6,a6
                rte                    load the status reg and PC from the stack and commence running
                                       *used to be rte but this didn't load the status byte

; C:\USERS\ADMIN\DESKTOP\ASSIGNMENT4\CACHE_CONTROLLER\SPEEDTEST\SPEEDTEST.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
; #include <stdio.h>
; /*********************************************************************************************
; **	RS232 port addresses defined as pointers
; *********************************************************************************************/
; #define RS232_Control     (*(volatile unsigned char *)(0x00400040))
; #define RS232_Status      (*(volatile unsigned char *)(0x00400040))
; #define RS232_TxData      (*(volatile unsigned char *)(0x00400042))
; #define RS232_RxData      (*(volatile unsigned char *)(0x00400042))
; #define RS232_Baud        (*(volatile unsigned char *)(0x00400044))
; /*********************************************************************************************
; **  Subroutine to initialise the RS232 Port by writing some commands to the internal registers
; **	Call this function at the start of the program before you attempt to read or write to hyperterminal
; *********************************************************************************************/
; void Init_RS232(void)
; {
_Init_RS232:
; RS232_Control = 0x15 ; //  %00010101 set up serial port to use divide by 16 clock, set RTS low, 8 bits no parity, 1 stop bit, transmitter interrupt disabled
       move.b    #21,4194368
; RS232_Baud = 0x1 ;      // program serial port speed: 000 = 230 kbaud, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
       move.b    #1,4194372
       rts
; }
; /*********************************************************************************************************
; **  Subroutine to provide a low level output function to 6850 ACIA
; **  This routine provides the basic functionality to output a single character to the serial Port
; **  to allow the board to communicate with HyperTerminal Program
; **
; **  NOTE you do NOT call this function directly, instead  call the normal putchar() function
; **  which in turn calls _putch() below.
; **
; **	Other functions like puts(), printf() call putchar() so will
; **  call _putch() below so it's fully integrates into the C standard library routines
; *********************************************************************************************************/
; int _putch(int c)
; {
__putch:
       link      A6,#0
; // write the character to the RS232 port first - comment out if not wanted
; while((RS232_Status & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
_putch_1:
       move.b    4194368,D0
       and.b     #2,D0
       cmp.b     #2,D0
       beq.s     _putch_3
       bra       _putch_1
_putch_3:
; ;
; RS232_TxData = (c & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
       move.l    8(A6),D0
       and.l     #127,D0
       move.b    D0,4194370
; return c ;                                              // putchar() expects the character to be returned
       move.l    8(A6),D0
       unlk      A6
       rts
; }
; /*********************************************************************************************************
; **  Subroutine to provide a low level input function to 6850 ACIA
; **  This routine provides the basic functionality to input a single character from the serial Port
; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
; **
; **  NOTE you do not call this function directly, instead you call the normal getchar() function
; **  which in turn calls _getch() below).
; **	Other functions like gets(), scanf() call getchar() so will
; **  call _getch() below so it's fully integrates into the C standard library routines
; *********************************************************************************************************/
; int _getch( void )
; {
__getch:
; while((RS232_Status & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
_getch_1:
       move.b    4194368,D0
       and.b     #1,D0
       cmp.b     #1,D0
       beq.s     _getch_3
       bra       _getch_1
_getch_3:
; ;
; return (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
       move.b    4194370,D0
       and.l     #255,D0
       and.l     #127,D0
       rts
; }
; int a[100][100], b[100][100], c[100][100];
; int i, j, k, sum;
; int main(void)
; {
_main:
       movem.l   A2/A3/A4/A5,-(A7)
       lea       _i.L,A2
       lea       _k.L,A3
       lea       _j.L,A4
       lea       _sum.L,A5
; Init_RS232();
       jsr       _Init_RS232
; printf("\n\nStart.....");
       pea       @speedt~1_1.L
       jsr       _printf
       addq.w    #4,A7
; for(i=0; i <50; i ++)  {
       clr.l     (A2)
main_1:
       move.l    (A2),D0
       cmp.l     #50,D0
       bge       main_3
; printf("%d ", i);
       move.l    (A2),-(A7)
       pea       @speedt~1_2.L
       jsr       _printf
       addq.w    #8,A7
; for(j=0; j < 50; j++)  {
       clr.l     (A4)
main_4:
       move.l    (A4),D0
       cmp.l     #50,D0
       bge       main_6
; sum = 0 ;
       clr.l     (A5)
; for(k=0; k <50; k++)   {
       clr.l     (A3)
main_7:
       move.l    (A3),D0
       cmp.l     #50,D0
       bge       main_9
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
; sum = sum + b[i][k] * b[k][j] + a[i][k] * c[i][j];
       move.l    (A5),D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _b.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A3),D0
       muls      #400,D0
       lea       _b.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    (A2),D1
       muls      #400,D1
       lea       _a.L,A0
       add.l     D1,A0
       move.l    (A3),D1
       lsl.l     #2,D1
       move.l    D0,-(A7)
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A1
       add.l     D0,A1
       move.l    (A7)+,D0
       move.l    D0,-(A7)
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    0(A0,D1.L),-(A7)
       move.l    0(A1,D0.L),-(A7)
       jsr       LMUL
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    (A7)+,D0
       add.l     D1,D0
       move.l    D0,(A5)
       addq.l    #1,(A3)
       bra       main_7
main_9:
; }
; c[i][j] = sum ;
       move.l    (A2),D0
       muls      #400,D0
       lea       _c.L,A0
       add.l     D0,A0
       move.l    (A4),D0
       lsl.l     #2,D0
       move.l    (A5),0(A0,D0.L)
       addq.l    #1,(A4)
       bra       main_4
main_6:
       addq.l    #1,(A2)
       bra       main_1
main_3:
; }
; }
; printf("\n\nDone.....");
       pea       @speedt~1_3.L
       jsr       _printf
       addq.w    #4,A7
; return 0 ;
       clr.l     D0
       movem.l   (A7)+,A2/A3/A4/A5
       rts
; }
ULMUL:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       bra.s   lmul_3
LMUL:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       tst.l   D0
       bpl.s   lmul_1
       neg.l   D0
       tst.l   D1
       bpl.s   lmul_2
       neg.l   D1
       bra.s   lmul_3
lmul_1:
       tst.l   D1
       bpl.s   lmul_3
       neg.l   D1
lmul_2:
       bsr.s   domul
       neg.l   D1
       negx.l  D0
       bra.s   lmul_4
lmul_3:
       bsr.s   domul
lmul_4:
       move.l  D1,8(A6)
       movem.l (A7)+,D0/D1
       unlk    A6
       rts
domul:
       cmpi.l  #$FFFF,D1
       bhi.s   domul_1
       cmpi.l  #$FFFF,D0
       bhi.s   domul_2
       mulu    D0,D1
       rts
domul_1:
       cmpi.l  #$FFFF,D0
       bhi.s   domul_4
       bra.s   domul_3
domul_2
       exg     D0,D1
domul_3:
       move.l  D2,-(A7)
       move.l  D1,D2
       swap    D2
       mulu    D0,D1
       mulu    D0,D2
       swap    D2
       clr.w   D2
       add.l   D2,D1
       move.l  (A7)+,D2
       rts
domul_4:
       movem.l D2/D3,-(A7)
       move.l  D1,D2
       move.l  D1,D3
       mulu    D0,D1
       swap    D2
       mulu    D0,D2
       swap    D0
       mulu    D0,D3
       add.l   D3,D2
       swap    D2
       clr.w   D2
       add.l   D2,D1
       movem.l (A7)+,D2/D3
       rts
_printf:
       link      A6,#-4
       move.l    D2,-(A7)
       lea       8(A6),A0
       addq.w    #4,A0
       move.l    A0,D2
       move.l    D2,-(A7)
       move.l    8(A6),-(A7)
       clr.l     -(A7)
       jsr       _doprint
       add.w     #12,A7
       move.l    D0,-4(A6)
       clr.l     D2
       move.l    -4(A6),D0
       move.l    (A7)+,D2
       unlk      A6
       rts
@doprint_copy:
       link      A6,#0
       move.l    8(A6),A0
       tst.l     (A0)
       beq.s     @doprint_copy_1
       move.l    12(A6),D0
       move.l    8(A6),A0
       move.l    (A0),A1
       addq.l    #1,(A0)
       move.b    D0,(A1)
       bra.s     @doprint_copy_2
@doprint_copy_1:
       move.l    12(A6),-(A7)
       jsr       _putch
       addq.w    #4,A7
@doprint_copy_2:
       unlk      A6
       rts
@doprint_getval:
       link      A6,#0
       movem.l   D2/D3,-(A7)
       move.l    8(A6),D3
       clr.l     D2
       move.l    D3,A0
       move.l    (A0),A0
       move.b    (A0),D0
       cmp.b     #42,D0
       bne.s     @doprint_getval_1
       move.l    12(A6),A0
       move.l    (A0),A1
       addq.l    #4,(A0)
       move.l    (A1),D2
       move.l    D3,A0
       addq.l    #1,(A0)
       bra       @doprint_getval_5
@doprint_getval_1:
       moveq     #1,D0
       move.l    D3,A0
       move.l    (A0),A0
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       add.l     D1,D0
       lea       __ctype.L,A0
       move.b    0(A0,D0.L),D0
       and.b     #4,D0
       beq.s     @doprint_getval_5
       move.l    D2,-(A7)
       pea       10
       jsr       LMUL
       move.l    (A7),D0
       addq.w    #8,A7
       move.l    D3,A0
       move.l    (A0),A1
       addq.l    #1,(A0)
       move.b    (A1),D1
       ext.w     D1
       ext.l     D1
       add.l     D1,D0
       sub.l     #48,D0
       move.l    D0,D2
       bra       @doprint_getval_1
@doprint_getval_5:
       move.l    D2,D0
       movem.l   (A7)+,D2/D3
       unlk      A6
       rts
_doprint:
       link      A6,#-52
       movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
       lea       8(A6),A2
       lea       @doprint_copy.L,A3
       lea       _ultoa.L,A4
       clr.l     D6
doprint_1:
       move.l    12(A6),A0
       tst.b     (A0)
       beq       doprint_3
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #37,D0
       beq.s     doprint_4
       move.l    12(A6),A0
       addq.l    #1,12(A6)
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       doprint_2
doprint_4:
       addq.l    #1,12(A6)
       clr.b     -45(A6)
       clr.b     -46(A6)
       clr.b     -48(A6)
       clr.b     -49(A6)
       clr.b     -50(A6)
       clr.b     -51(A6)
       clr.l     -4(A6)
       moveq     #-1,D5
       lea       -36(A6),A0
       move.l    A0,D3
       move.l    A0,D2
doprint_6:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #43,D0
       beq.s     doprint_12
       bgt.s     doprint_15
       cmp.l     #35,D0
       beq       doprint_14
       bgt       doprint_9
       cmp.l     #32,D0
       beq.s     doprint_13
       bra.s     doprint_9
doprint_15:
       cmp.l     #45,D0
       beq.s     doprint_11
       bra.s     doprint_9
doprint_11:
       move.b    #1,-51(A6)
       addq.l    #1,12(A6)
       bra.s     doprint_7
doprint_12:
       move.b    #1,-50(A6)
       addq.l    #1,12(A6)
       bra.s     doprint_7
doprint_13:
       move.b    #1,-49(A6)
       addq.l    #1,12(A6)
       bra.s     doprint_7
doprint_14:
       move.b    #1,-48(A6)
       addq.l    #1,12(A6)
       bra.s     doprint_7
doprint_9:
       bra.s     doprint_8
doprint_7:
       bra       doprint_6
doprint_8:
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #48,D0
       bne.s     doprint_16
       addq.l    #1,12(A6)
       move.b    #1,-46(A6)
doprint_16:
       pea       16(A6)
       pea       12(A6)
       jsr       @doprint_getval
       addq.w    #8,A7
       move.l    D0,A5
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #46,D0
       bne.s     doprint_18
       addq.l    #1,12(A6)
       pea       16(A6)
       pea       12(A6)
       jsr       @doprint_getval
       addq.w    #8,A7
       move.l    D0,D5
doprint_18:
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #108,D0
       bne.s     doprint_20
       addq.l    #1,12(A6)
       move.b    #1,-45(A6)
doprint_20:
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #111,D0
       beq       doprint_27
       bgt.s     doprint_33
       cmp.l     #100,D0
       beq       doprint_24
       bgt.s     doprint_34
       cmp.l     #99,D0
       beq       doprint_30
       bgt       doprint_22
       cmp.l     #88,D0
       beq       doprint_28
       bra       doprint_22
doprint_34:
       cmp.l     #105,D0
       beq.s     doprint_24
       bra       doprint_22
doprint_33:
       cmp.l     #117,D0
       beq       doprint_26
       bgt.s     doprint_35
       cmp.l     #115,D0
       beq       doprint_31
       bra       doprint_22
doprint_35:
       cmp.l     #120,D0
       beq       doprint_28
       bra       doprint_22
doprint_24:
       tst.b     -45(A6)
       beq.s     doprint_36
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       _ltoa
       add.w     #12,A7
       bra.s     doprint_37
doprint_36:
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       _ltoa
       add.w     #12,A7
doprint_37:
       bra       doprint_23
doprint_26:
       tst.b     -45(A6)
       beq.s     doprint_38
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     doprint_39
doprint_38:
       pea       10
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
doprint_39:
       bra       doprint_23
doprint_27:
       tst.b     -45(A6)
       beq.s     doprint_40
       pea       8
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     doprint_41
doprint_40:
       pea       8
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
doprint_41:
       bra       doprint_23
doprint_28:
       tst.b     -45(A6)
       beq.s     doprint_42
       pea       16
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
       bra.s     doprint_43
doprint_42:
       pea       16
       move.l    D3,-(A7)
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),-(A7)
       jsr       (A4)
       add.w     #12,A7
doprint_43:
       bra       doprint_23
doprint_30:
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),D0
       move.l    D2,A0
       addq.l    #1,D2
       move.b    D0,(A0)
       move.l    D2,A0
       clr.b     (A0)
       move.l    A5,D0
       beq.s     doprint_44
       move.l    A5,D0
       bra.s     doprint_45
doprint_44:
       moveq     #1,D0
       ext.w     D0
       ext.l     D0
doprint_45:
       move.l    D0,D5
       bra       doprint_23
doprint_31:
       move.l    16(A6),A0
       addq.l    #4,16(A6)
       move.l    (A0),D3
       cmp.l     #-1,D5
       bne.s     doprint_46
       move.l    D3,-(A7)
       jsr       _strlen
       addq.w    #4,A7
       move.l    D0,D5
doprint_46:
       bra.s     doprint_23
doprint_22:
       move.l    12(A6),A0
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       move.l    D2,A0
       clr.b     (A0)
doprint_23:
       move.l    D3,-(A7)
       jsr       _strlen
       addq.w    #4,A7
       move.b    D0,D4
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #115,D0
       bne.s     doprint_48
       cmp.l     #0,D5
       blt.s     doprint_48
       ext.w     D4
       ext.l     D4
       cmp.l     D5,D4
       ble.s     doprint_50
       move.l    D5,D0
       bra.s     doprint_51
doprint_50:
       move.b    D4,D0
       ext.w     D0
       ext.l     D0
doprint_51:
       move.b    D0,D4
doprint_48:
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #88,D0
       bne       doprint_56
       lea       -36(A6),A0
       move.l    A0,D2
doprint_54:
       move.l    D2,A0
       tst.b     (A0)
       beq.s     doprint_56
       move.l    D2,A0
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       jsr       _toupper
       addq.w    #4,A7
       move.l    D2,A0
       move.b    D0,(A0)
       addq.l    #1,D2
       bra       doprint_54
doprint_56:
       moveq     #0,D7
       lea       -44(A6),A0
       move.l    A0,D2
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #100,D0
       beq.s     doprint_59
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #105,D0
       bne       doprint_65
doprint_59:
       move.b    -50(A6),D0
       ext.w     D0
       ext.l     D0
       tst.l     D0
       bne.s     doprint_62
       move.l    D3,A0
       move.b    (A0),D0
       cmp.b     #45,D0
       bne       doprint_60
doprint_62:
       move.l    D3,A0
       move.b    (A0),D0
       cmp.b     #45,D0
       bne.s     doprint_63
       move.l    D3,A0
       addq.l    #1,D3
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       subq.b    #1,D4
       bra.s     doprint_64
doprint_63:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #43,(A0)
doprint_64:
       addq.l    #1,D7
       bra       doprint_65
doprint_60:
       tst.b     -49(A6)
       beq.s     doprint_65
       move.l    D3,A0
       move.b    (A0),D0
       cmp.b     #45,D0
       bne.s     doprint_67
       move.l    D3,A0
       addq.l    #1,D3
       move.l    D2,A1
       addq.l    #1,D2
       move.b    (A0),(A1)
       subq.b    #1,D4
       bra.s     doprint_68
doprint_67:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #32,(A0)
doprint_68:
       addq.l    #1,D7
doprint_65:
       tst.b     -48(A6)
       beq       doprint_77
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #111,D0
       beq.s     doprint_73
       bgt.s     doprint_76
       cmp.l     #88,D0
       beq.s     doprint_73
       bra       doprint_77
doprint_76:
       cmp.l     #120,D0
       beq.s     doprint_73
       bra       doprint_77
doprint_73:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #48,(A0)
       addq.l    #1,D7
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #120,D0
       beq.s     doprint_79
       move.l    12(A6),A0
       move.b    (A0),D0
       cmp.b     #88,D0
       bne.s     doprint_77
doprint_79:
       move.l    D2,A0
       addq.l    #1,D2
       move.b    #120,(A0)
       addq.l    #1,D7
doprint_77:
       move.l    D2,A0
       clr.b     (A0)
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #105,D0
       beq       doprint_82
       bgt.s     doprint_93
       cmp.l     #99,D0
       beq       doprint_96
       bgt.s     doprint_94
       cmp.l     #88,D0
       beq       doprint_82
       bgt       doprint_80
       cmp.l     #69,D0
       beq       doprint_82
       bra       doprint_80
doprint_94:
       cmp.l     #101,D0
       beq       doprint_82
       bgt       doprint_80
       cmp.l     #100,D0
       beq.s     doprint_82
       bra       doprint_80
doprint_93:
       cmp.l     #117,D0
       beq.s     doprint_82
       bgt.s     doprint_95
       cmp.l     #115,D0
       beq       doprint_96
       bgt       doprint_80
       cmp.l     #111,D0
       beq.s     doprint_82
       bra       doprint_80
doprint_95:
       cmp.l     #120,D0
       beq.s     doprint_82
       bra       doprint_80
doprint_82:
       tst.b     -46(A6)
       beq.s     doprint_96
       tst.b     -51(A6)
       bne.s     doprint_96
       move.l    A5,D0
       sub.l     D7,D0
       ext.w     D4
       ext.l     D4
       sub.l     D4,D0
       move.l    D0,-4(A6)
doprint_96:
       move.l    -4(A6),D0
       cmp.l     #0,D0
       bge.s     doprint_98
       clr.l     -4(A6)
doprint_98:
       tst.b     -51(A6)
       bne       doprint_104
       move.b    D4,D0
       ext.w     D0
       ext.l     D0
       add.l     -4(A6),D0
       add.l     D7,D0
       move.b    D0,-47(A6)
doprint_102:
       move.b    -47(A6),D0
       ext.w     D0
       ext.l     D0
       move.l    A5,D1
       subq.w    #1,A5
       cmp.l     D1,D0
       bge.s     doprint_104
       pea       32
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       doprint_102
doprint_104:
       lea       -44(A6),A0
       move.l    A0,D2
doprint_105:
       move.l    D2,A0
       tst.b     (A0)
       beq.s     doprint_107
       move.l    D2,A0
       addq.l    #1,D2
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       doprint_105
doprint_107:
       move.l    -4(A6),D0
       move.b    D0,-47(A6)
doprint_108:
       move.b    -47(A6),D0
       subq.b    #1,-47(A6)
       tst.b     D0
       beq.s     doprint_110
       pea       48
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra       doprint_108
doprint_110:
       move.l    D3,A0
       tst.b     (A0)
       beq       doprint_113
       move.l    12(A6),A0
       move.b    (A0),D0
       ext.w     D0
       ext.l     D0
       cmp.l     #115,D0
       beq.s     doprint_116
       bgt.s     doprint_119
       cmp.l     #99,D0
       beq.s     doprint_116
       bra.s     doprint_119
doprint_116:
       move.l    D5,D0
       subq.l    #1,D5
       cmp.l     #0,D0
       bgt.s     doprint_119
       bra.s     doprint_115
doprint_119:
       move.l    D3,A0
       addq.l    #1,D3
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
       bra.s     doprint_112
doprint_115:
       bra.s     doprint_113
doprint_112:
       bra       doprint_110
doprint_113:
       tst.b     -51(A6)
       beq       doprint_125
       move.b    D4,D0
       ext.w     D0
       ext.l     D0
       add.l     -4(A6),D0
       add.l     D7,D0
       move.b    D0,-47(A6)
doprint_123:
       move.b    -47(A6),D0
       ext.w     D0
       ext.l     D0
       move.l    A5,D1
       subq.w    #1,A5
       cmp.l     D1,D0
       bge.s     doprint_125
       pea       32
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       subq.l    #1,D6
       bra       doprint_123
doprint_125:
       bra.s     doprint_81
doprint_80:
       move.l    12(A6),A0
       move.b    (A0),D1
       ext.w     D1
       ext.l     D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
       addq.l    #1,D6
doprint_81:
       addq.l    #1,12(A6)
doprint_2:
       bra       doprint_1
doprint_3:
       tst.l     (A2)
       beq.s     doprint_126
       clr.b     D1
       and.l     #255,D1
       move.l    D1,-(A7)
       move.l    A2,-(A7)
       jsr       (A3)
       addq.w    #8,A7
doprint_126:
       move.l    D6,D0
       movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
       unlk      A6
       rts
@itoa_convert:
       link      A6,#0
       movem.l   D2/D3/D4/D5,-(A7)
       move.l    8(A6),D2
       move.l    16(A6),D3
       move.l    12(A6),D5
       move.l    D5,-(A7)
       move.l    D3,-(A7)
       jsr       ULDIV
       move.l    4(A7),D0
       addq.w    #8,A7
       move.l    D0,D4
       cmp.l     D3,D5
       blo.s     @itoa_convert_1
       move.l    D3,-(A7)
       move.l    D5,-(A7)
       move.l    D3,-(A7)
       jsr       ULDIV
       move.l    (A7),D1
       addq.w    #8,A7
       move.l    D1,-(A7)
       move.l    D2,-(A7)
       jsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D2
@itoa_convert_1:
       cmp.l     #9,D4
       bgt.s     @itoa_convert_3
       move.l    D4,D0
       moveq     #48,D1
       and.l     #255,D1
       add.l     D1,D0
       bra.s     @itoa_convert_4
@itoa_convert_3:
       move.l    D4,D0
       moveq     #97,D1
       and.l     #255,D1
       add.l     D1,D0
       sub.l     #10,D0
@itoa_convert_4:
       move.l    D2,A0
       move.b    D0,(A0)
       move.l    D2,D0
       addq.l    #1,D0
       movem.l   (A7)+,D2/D3/D4/D5
       unlk      A6
       rts
_ltoa:
       link      A6,#0
       movem.l   D2/D3/D4/D5,-(A7)
       move.l    8(A6),D2
       move.l    12(A6),D3
       move.l    16(A6),D5
       move.l    D3,D4
       cmp.l     #2,D5
       blt.s     ltoa_3
       cmp.l     #36,D5
       ble.s     ltoa_1
ltoa_3:
       move.l    D3,D0
       bra       ltoa_4
ltoa_1:
       cmp.l     #10,D5
       bne       ltoa_5
       cmp.l     #0,D2
       bge.s     ltoa_5
       move.l    D2,D0
       neg.l     D0
       move.l    D0,D2
       cmp.l     #0,D2
       bge.s     ltoa_7
       pea       @itoa_1.L
       move.l    D3,-(A7)
       jsr       _strcpy
       addq.w    #8,A7
       move.l    D3,D0
       bra.s     ltoa_4
ltoa_7:
       move.l    D4,A0
       addq.l    #1,D4
       move.b    #45,(A0)
ltoa_5:
       move.l    D5,-(A7)
       move.l    D2,-(A7)
       move.l    D4,-(A7)
       jsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D4
       move.l    D4,A0
       clr.b     (A0)
       move.l    D3,D0
ltoa_4:
       movem.l   (A7)+,D2/D3/D4/D5
       unlk      A6
       rts
_ultoa:
       link      A6,#0
       movem.l   D2/D3/D4,-(A7)
       move.l    16(A6),D3
       move.l    12(A6),D4
       move.l    D4,D2
       cmp.l     #2,D3
       blt.s     ultoa_3
       cmp.l     #36,D3
       ble.s     ultoa_1
ultoa_3:
       move.l    D4,D0
       bra.s     ultoa_4
ultoa_1:
       move.l    D3,-(A7)
       move.l    8(A6),-(A7)
       move.l    D2,-(A7)
       jsr       @itoa_convert
       add.w     #12,A7
       move.l    D0,D2
       move.l    D2,A0
       clr.b     (A0)
       move.l    D4,D0
ultoa_4:
       movem.l   (A7)+,D2/D3/D4
       unlk      A6
       rts
_itoa:
       link      A6,#0
       move.l    16(A6),-(A7)
       move.l    12(A6),-(A7)
       move.l    8(A6),-(A7)
       jsr       _ltoa
       add.w     #12,A7
       unlk      A6
       rts
_strlen:
       move.l    (4,A7),A0
       move.l    A0,A1
strlen_1:
       tst.b     (A1)+
       bne       strlen_1
       move.l    A1,D0
       sub.l     A0,D0
       subq.l    #1,D0
       rts
_putch:
       link      A6,#0
       move.l    D2,-(A7)
       move.l    8(A6),D2
       cmp.l     #10,D2
       bne.s     putch_1
       pea       13
       jsr       __putch
       addq.w    #4,A7
putch_1:
       move.l    D2,-(A7)
       jsr       __putch
       addq.w    #4,A7
       move.l    D2,D0
       move.l    (A7)+,D2
       unlk      A6
       rts
_toupper:
       move.l    4(A7),D0
       cmp.l     #'a',D0
       blt.s     toupper_1
       cmp.l     #'z',D0
       bgt.s     toupper_1
       sub.l     #$20,D0
toupper_1:
       rts
_strcpy:
       move.l    (4,A7),A0
       move.l    (8,A7),A1
       move.l    A0,D0
strcpy_1:
       move.b    (A1)+,(A0)+
       bne.s     strcpy_1
       rts
ULDIV:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       bra.s   ldiv_3
LDIV:
       link    A6,#0
       movem.l D0/D1,-(A7)
       move.l  8(A6),D1
       move.l  12(A6),D0
       tst.l   D0
       bpl.s   ldiv_1
       neg.l   D0
       tst.l   D1
       bpl.s   ldiv_2
       neg.l   D1
       bsr.s   dodiv
       neg.l   D1
       bra.s   ldiv_4
ldiv_1:
       tst.l   D1
       bpl.s   ldiv_3
       neg.l   D1
       bsr.s   dodiv
       neg.l   D0
       bra.s   ldiv_4
ldiv_2:
       bsr.s   dodiv
       neg.l   D0
       neg.l   D1
       bra.s   ldiv_4
ldiv_3:
       bsr.s   dodiv
ldiv_4:
       move.l  D0,8(A6)
       move.l  D1,12(A6)
       movem.l (A7)+,D0/D1
       unlk    A6
       rts
dodiv:
       cmpi.l  #$FFFF,D1
       bhi.s   dodiv_2
       cmpi.l  #$FFFF,D0
       bhi.s   dodiv_1
       divu    D1,D0
       move.l  D0,D1
       clr.w   D1
       swap    D1
       andi.l  #$FFFF,D0
       rts
dodiv_1:
       movem.w D0/D2,-(A7)
       clr.w   D0
       swap    D0
       divu    D1,D0
       move.w  D0,D2
       move.w  (A7)+,D0
       divu    D1,D0
       swap    D0
       clr.l   D1
       move.w  D0,D1
       move.w  D2,D0
       swap    D0
       move.w  (A7)+,D2
       rts
dodiv_2:
       movem.l D2/D3/D4,-(A7)
       move.l  D1,D2
       clr.w   D2
       swap    D2
       addq.l  #1,D2
       move.l  D0,D3
       move.l  D1,D4
       move.l  D2,D1
       bsr.s   dodiv_1
       move.l  D4,D1
       divu    D2,D1
       divu    D1,D0
       andi.l  #$FFFF,D0
dodiv_3:
       move.l  D4,D1
       move.l  D4,D2
       swap    D2
       mulu    D0,D1
       mulu    D0,D2
       swap    D2
       add.l   D2,D1
       sub.l   D3,D1
       bhi.s   dodiv_4
       neg.l   D1
       cmp.l   D1,D4
       bhi.s   dodiv_5
       addq.l  #1,D0
       bra.s   dodiv_3
dodiv_4:
       subq.l  #1,D0
       bra.s   dodiv_3
dodiv_5:
       movem.l (A7)+,D2/D3/D4
       rts
       section   const

@speedt~1_1:
       dc.b      10,10,83,116,97,114,116,46,46,46,46,46,0
@speedt~1_2:
       dc.b      37,100,32,0
@speedt~1_3:
       dc.b      10,10,68,111,110,101,46,46,46,46,46,0
@itoa_1:
       dc.b      45,50,49,52,55,52,56,51,54,52,56,0
__ctype:
       dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
       dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
       dc.b      64,64,64,208,160,160,160,160,160,160,160,160
       dc.b      160,160,160,160,160,160,160,140,140,140,140
       dc.b      140,140,140,140,140,140,160,160,160,160,160
       dc.b      160,160,138,138,138,138,138,138,130,130,130
       dc.b      130,130,130,130,130,130,130,130,130,130,130
       dc.b      130,130,130,130,130,130,160,160,160,160,160
       dc.b      160,137,137,137,137,137,137,129,129,129,129
       dc.b      129,129,129,129,129,129,129,129,129,129,129
       dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       section   data
                align
DataStart       equ       *

*********************************************************************************************************
* Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
* to ram as part of the CStart routine in this file
*********************************************************************************************************

       section   bss
                align
DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it

*********************************************************************************************************
* Section for Uninitialised Data held in ROM as constants
*********************************************************************************************************

                org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup


bss             org       bss

*********************************************************************************************************
* Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
* install the exception handler using the C function InstallExceptionHandler()
*********************************************************************************************************



VInitialSP       ds.l    1      dummy as we can't really install a handler for this
VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
VBusError        ds.l    1      storage for address of Bus Error Handler
VAddressError    ds.l    1      storage for address of Address Error Handler
VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
VDividebyZero    ds.l    1      storage for address of divide by zero handler
VCheck           ds.l    1      ditto
VTrapV           ds.l    1      ditto
VPrivilege       ds.l    1      ditto
VTrace           ds.l    1
VLine1010emul    ds.l    1
VLine1111emul    ds.l    1
VUnassigned1     ds.l    1
VUnassigned2     ds.l    1
VUnassigned3     ds.l    1
VUninit_IRQ      ds.l    1
VUnassigned4     ds.l    1
VUnassigned5     ds.l    1
VUnassigned6     ds.l    1
VUnassigned7     ds.l    1
VUnassigned8     ds.l    1
VUnassigned9     ds.l    1
VUnassigned10    ds.l    1
VUnassigned11    ds.l    1
VSpuriousIRQ     ds.l    1

* Interrupt handlers Vector 25-31
VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()

* Trap Handler vectors 32-47
VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()

* the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here

***********************************************************************************************************
* Other Variables
***********************************************************************************************************
*__DebugA5       ds.l    1
*__UserA5        ds.l    1

***********************************************************************************************************
__ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
__allocp:       ds.l    0       ; start of allocation units
__heap:         ds.l    0       ; pointers for malloc functions

*__himem:       ds.l    himem            ; highest memory location + 1
*__stklen:      ds.l    stklen           ; default stack size

*********************************************************************************************************
* Section for Heap
*********************************************************************************************************

_a:
       ds.b      40000
_b:
       ds.b      40000
_c:
       ds.b      40000
_i:
       ds.b      4
_j:
       ds.b      4
_k:
       ds.b      4
_sum:
       ds.b      4
       section   heap
                align
bssEnd          equ *                   end of storage space for unitialised variables
*                                       we have to copy all initialised variable from rom to here at startup
heap   equ       *
                 align
